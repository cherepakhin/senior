<p><span style="font-weight: 400;"> <img class="pull-center" src="images/role.png" alt="" /></span></p>
<h3><b>Бизнес анализ</b></h3>
<p><i>"Немного есть вещей менее логичных, чем бизнес-логика"(Мартин Фаулер)</i></p>
<p><i>"То что сделано изначально плохо — в реальности, не только "никогда не будет переписано", но и приводит к постоянному крутому росту стоимости дальнейшей доставки нового функционала, а в перспективе способно полностью блокировать прогресс по проекту" (он же)</i></p>
<hr id="system-readmore" />
<p>Заказчик часто и сам мутно представляет, что же он в итоге хочет. Это нормально. В отличии от разработчиков, аналитики видят (должны видеть) проект более широко и дальше, в общих чертах. И хорошо, что в общих чертах. Scrum советует не грузиться перспективой развития проекта, но хотя бы на 2-3 sprintа вперед хочется видеть. Обсуждение перспектив проекта будет учтено при реализации разработчиками. Нужно найти форму общения с аналитиками (см. ниже "Бумажка"). Доносить через них вопросы до заказчика и это, возможно, повлечет за собой изменение бизнес процессов и функций конечных пользователей. Это нормально. Мы на это учились, должны предложить варианты и не скатываться в "автоматизацию хаоса".</p>
<h3><b>SDLC</b></h3>
<p>Есть такая штука Software development lifecycle (SDLC). Картинка пояснит суть лучше слов:<br/><br/>
    <img class="pull-center" src="images/sdlc" alt=""/><br/><br/>
    Ничего нового, но удерживая картинку перед глазами (не только своими), есть план разговора при обсуждении задач, оценки на какой стадии задача, прикинуть что нужно для решения задачи,
    сколько времени займет внедрение той или иной фичи. И, может быть главное, устанавливает "правила игры". Пример для <b>backend</b> разработчика:<br/><br/>
<table border="1" cellpadding="5">
    <tbody>
    <tr>
        <th>Цель</th>
        <th>Продолжительность</th>
        <th>Участники</th>
    </tr>
    <tr>
        <td>Анализ требований, понятна ли задача (берем в разработку?)</td>
        <td>1 час - 1 день</td>
        <td>аналитик+разработчик</td>
    </tr>
    <tr>
        <td>Прикинуть дизайн</td>
        <td>1 - 2 час, но с ограничением уложиться в спринт</td>
        <td>разработчик (возможно с devops инженером)</td>
    </tr>
    <tr>
        <td>Собственно разработка + unit тесты</td>
        <td>по результатам п 1,2</td>
        <td>разработчик</td>
    </tr>
    <tr>
        <td>Интеграционное тестирование</td>
        <td>0,5 дня - 1 день</td>
        <td>тестировщик+разработчик+devops инженер</td>
    </tr>
    <tr>
        <td>Деплой в пререлиз (удаление "фиче" ветки и т.п. зачистка)</td>
        <td>В конце спринта (в идеале)</td>
        <td>devops инженер</td>
    </tr>
    </tbody>
</table>
</p>
<h3><b>Майки</b></h3>
<p>Речь о разбиении на задачи по сложности и тех самых DoR (Definition of Ready). По уровню сложности, трудовых затрат задачи оцениваются по схеме X,M,L (размеры маек).</p>
<ul>
    <li>X - срок выполнения неизвестен. Задача не проработана. В работу не берем.</li>
    <li>M - задача боле-мене понятна, но за спринт точно не сделаем, может быть за два. Больше двух спринтов оцениваем как X.</li>
    <li>L - задача понятна и разработчик гарантирует сделать за один спринт</li>
</ul>
<p>Оценка приблизительна, и вполне может меняться при проработке. На пальцах выглядит так. Аналитики описывают требования. Эти требования фиксируются в Jira. Если можем, то в аттрибутах задачи сразу ставим оценку (д.б. настройка в jira). Или разбиваем требования на подзадачи. Стремимся разбить на подзадачи с оценкой L. Оценки ставят разработчики.</p>
<h3><b>Архитектура</b></h3>
<p>Смешивание логики слоев (обращения к СУБД прямо из rest).</p>
<p><span style="font-weight: 400;"> <span style="text-decoration: underline;"> DTO игнорируется</span>. Наружу отдаются “бородатые” Database Entity, которые сложно документировать и понимать фронту, связывают руки бек-эндерам при изменении в базе данных, тестировщики вешаются.<br /><br /> </span> <span style="font-weight: 400;"> Жирные классы среднего слоя, нужно дробить. Делить по функционалу. Существует какой-то психологический барьер, когда нужно добавить новый класс.<br /><em> (для кого я это написал, это и так на всех заборах и собеседованиях, а гляньте-ка на свой service слой. Что-то типа ShopRestController, ShopServiceImplementation. И никаких вариаций типа выделить PriceRestController из ShopRestController, тут же сразу <span style="text-decoration: underline;">захочется </span> PriceServiceImplementation выделить из ShopServiceImplementation и т.п.).</em> <br /> </span></p>
<p><span style="font-weight: 400;"> Архитектура кода приложения никак не контролируется. Если нужна какая-то новая функциональность, выбор размещения места для кода почти случаен (ибо scrum). Лайфхак: перед тем как писать новое или багфиксить, кратенько обсуждаем план. Ничего нового, слушаем друг друга. <br /> <br /> </span> <span style="font-weight: 400;">Про кеши все дружно забываем. <br /><br /> Необоснованное, бесконтрольное использование promise. И вообще: promise в Spring как-то очень подозрительно выглядит.<br /></span></p>
<p><span style="font-weight: 400;">Использование </span><strong>внешних</strong><span style="font-weight: 400;"> сервисов, всякие сторонние rest, xml сервисы с их контролем и режимом доступа и т.п. все сложности нужно прятать в отдельном сервисном слое (а лучше вообще в отдельном микросервисе). Из этого слоя показывать только то, что нужно для конкретной системы. Безопасность при обращении наружу опять же проще контролировать devops инженерам.</span> <span style="font-weight: 400;"><br /></span></p>
<p><span style="font-weight: 400;"> Вообще все общение микросервисов обычно делается только через REST. Использование очередей при обмене между микросервисами почему-то в <em>игноре</em> на бэке, только REST и точка.<br /><br /> Отдельно тут хочется упомянуть об использовании RabbitMQ. При непродуманном использовании, может ухудшить ситуацию, т.к. он “пушит” в приемный контроллер и создает отдельные потоки, на которые может не хватить ресурсов, если не указать max в rabbit обработчике.<br /> </span><span style="font-weight: 400;"><br /></span><span style="font-weight: 400;"> Обращение к СУБД не кешируются. </span><span style="font-weight: 400;"><br /></span></p>
<p><span style="font-weight: 400;"> REST запросы не кешируются. </span></p>
<p><span style="font-weight: 400;"> Rest должен отдавать только то, что должно лежать в отдельной библиотеке DTO. Речь идет о ведении отдельной <b>maven-зависимости</b> DTO. Д.б. согласовано с frontend-разработчиками и им понятно. Можно frontend разработчикам дать доступ к репозиторию DTO и настроить уведомления при изменениях для них. Документирование REST в этом случае сильно упрощается, описано в одном месте и не расползается на 150 вариантов во всяких wiki системах.<br /> </span> <span style="font-weight: 400;"> Можно рассмотреть 2 модели DTO для REST. <strong>DTOfull</strong> для диалогов и <strong>DTOshort</strong> для списков и т.п. Где какой использовать становится тривиальной задачей, решается за пару минут на дейлике. И не городить <b>отдельный</b> DTO на <strong>каждый</strong> <strong>метод</strong> REST контроллера. А еще можно добавить SimpleDto(long id, string name) когда не решили еще что же мы хотим от REST метода. Ну и заодно это "маячок" типа TODO. Можно от нее наследоваться, т.к. подавляющее кол-во JSON ответов имеют эти поля. Все что отдается наружу все должно быть в модели DTO. Id в DTO все таки нужен. Фронт у себя кеширует ответы, и по id дергает из кэша приложения в браузере, да и вообще не по имени же идентифицировать объект, хотя почему бы и нет.<br /><br /> Второе - это "психологический" момент. Мыслим бизнес сущностями, а не сущностями СУБД. Entity это средство, а не цель. Frontend разработчикам, аналитикам, тестировщикам, может быть, лучше вообще не знать структуру СУБД. </span></p>
<p>Сценарий: <br />1. Встречаемся, договариваемся о пути rest и набрасываем параметры запроса и json ответа (или лучше выбираем уже существующий DTO). И не выкручиваем руки фронту, они по другому мыслят, другими задачами (ну разве что чуток фильтруем их хотелки). В общем договариваемся.<br /> 2. Держим в курсе этих дел тестировщиков (они сразу уже могут начать писать сценарии тестирования).<br /> 3. Идем работать.</p>
<p><span style="font-weight: 400;">Внутри бэка </span><b>возможно</b><span style="font-weight: 400;"> использование отдельного слоя DTO для обмена между микросервисами, т.к. внешние DTO регламентированы, а Entity завязаны на базу. Внутренние DTO под свой вкус можно наделать. Для конвертации в/из DTO использовал <a style="color: #3366ff; text-decoration: underline;" href="https://mapstruct.org/" target="_blank" rel="noopener noreferrer">mapstruct</a>. <a style="color: #3366ff; text-decoration: underline;" href="http://modelmapper.org/" target="_blank" rel="noopener noreferrer">ModelMapper</a> тоже хорош. Но и рукописные конверторы бывают нужны. Ничего сложного.</span></p>
<p><span style="font-weight: 400;"> Обмен между микросервисами может быть не только через REST, но и через очереди, не всегда нужен результат обработки запроса прямо сейчас. Как то забывается частенько. Иногда, достаточно по-быстрому проверить корректность вх.параметров, отправить в очередь запрос, отдать Ок, и "забить" на него. Вроде тривиально, а все равно вокруг одни RESTы при обмене между микросервисами и никаких вариантов. <br /><br /> Многопроектный проект в idea. Если пишешь один, то супер. Если в команде - засада (имхо). Исключение - karaf.</span></p>
<p><span style="font-weight: 400;"> Отдельно про camunda. Часто мы встречаемся с бизнес-процессами. Важно их увидеть. И не заниматься реализацией BPM в "рукопашку".</span></p>
<h3><b>CI/CD</b></h3>
<p><a style="color: #3366ff; text-decoration: underline;" href="index.php/50-organizatsiya-sobstvennogo-ci-cd" target="_blank" rel="noopener noreferrer">Использование собственного CI/CD</a></p>
<h3><b>Тестирование</b></h3>
<p><span style="font-weight: 400;"> При создании отчетов о покрытии тестами использовал jacoco.</span></p>
<p><strong> <span style="font-weight: 400;"> Интеграционные тестирование чаще ручное, хотя есть <span style="color: #3366ff;"><span style="text-decoration: underline;"><a style="color: #3366ff; text-decoration: underline;" href="https://pypi.org/project/pytest/" target="_blank" rel="noopener noreferrer">pytest</a></span></span> и скрипты pytest. Утилита <span style="text-decoration: underline; color: #3366ff;"><a style="color: #3366ff; text-decoration: underline;" title="behave" href="https://behave.readthedocs.io/en/stable/" target="_blank" rel="noopener noreferrer">behave</a></span> вообще волшебная штука для интеграционных тестов. И не надо уточнять детали запроса. Все есть в тесте. Особенно с выводом результатов в формате allure. Отдельный репозиторий для тестов, доступный всем разработчикам. </span> </strong></p>
<p><span style="font-weight: 400;"> <img class="pull-center" src="images/allure5.png" alt="" /></span></p>
<p><span style="font-weight: 400;"> <img class="pull-center" src="images/allure6.png" alt="" /></span></p>
<p>Результат отработки тестовых скриптов behave.</p>
<p>С помощью behave даже удавалось АВТОМАТИЧЕСКИ тестировать целый бизнес процесс из нескольких этапов.<br /> Подробнее:</p>
<ul>
    <li><a style="text-decoration: underline; color: #3366ff;" href="index.php/34-behave-testirovanie" target="_blank" rel="noopener noreferrer">Интеграционное тестирование</a></li>
    <li><a style="text-decoration: underline; color: #3366ff;" href="index.php/41-prostoe-testirovanie-junit5-s-vyvodom-rezultatov-v-allure" target="_blank" rel="noopener noreferrer">Интеграционное тестирование JUnit5 с выводом результатов в Allure</a></li>
</ul>
<p><span style="font-weight: 400;">В конце концов, скрипты <span style="text-decoration: underline; color: #3366ff;"> <a style="text-decoration: underline; color: #3366ff;" href="https://httpie.io/" target="_blank" rel="noopener noreferrer">httpie</a> </span>. И не нужно мучаться через web интерфейс с ручным вводом. Бек-эндеры могут помочь тестировщикам в этом деле. Что бывает <span style="text-decoration: underline;">психологически(?) </span> сложно принять для тестировщиков. "Я тут через браузер все руками попробовал и я уверен, а ты мне какую-то левую утилиту подсовываешь". <br /></span> <br /> <span style="font-weight: 400;"> Для нагрузочных испытаний, есть классная утилита <span style="text-decoration: underline; color: #3366ff;"> <a style="text-decoration: underline; color: #3366ff;" title="yandex-tank" href="https://github.com/yandex/yandex-tank" target="_blank" rel="noopener noreferrer">yandex-tank. </a> <a style="text-decoration: underline; color: #3366ff;" title="yandex-tank" href="https://github.com/cherepakhin/lot4/blob/master/doc/load.md" target="_blank" rel="noopener noreferrer">(Пример использования).</a> </span> </span></p>
<p><span style="font-weight: 400;">Для создания отчетов покрытия тестами использовал jacoco.</span></p>
<h3><b>Документация.</b></h3>
<p><span style="font-weight: 400;">Для создания документации для разработчика использовал OpenApi, Swagger. Ну и rest по быстрому проверить можно. Столкнулся с требованием заказчика не использовать Swagger.</span></p>
<h3><b>Многопоточка.</b></h3>
<p><span style="font-weight: 400;">Игнорируется возможности Springa при многопоточности. </span><span style="font-weight: 400;">Бесконтрольное (а чаще бессмысленное) использование многопоточки. Все начинается с Promise в ответе метода. </span><span style="font-weight: 400;">Promise расползается везде, как короновирус =&gt; сложное программирование на promis-ах, сложное тестирование. Вообще 300 раз надо подумать, перед тем как возвращать Promise. (Да-да! Я не умею его готовить. Ок. А заодно вспомните что же такое RestController и Spring вообще?). Для себя использую такое правило: где породил Promise, тут же его и разруливай, если уж без него никак, и желательно через private. т.к. это локальное решение и не надо ради него усложнять остальной код, опять же вспоминаем что такое Spring. <br /></span></p>
<h3>Бумажка</h3>
<p>Реально зашли такие графические средства как <span style="text-decoration: underline;"> <span style="color: #3366ff;"><a style="color: #3366ff; text-decoration: underline;" title="Пример" href="https://miro.com/" target="_blank" rel="noopener noreferrer">miro.com</a></span> </span>, <span style="text-decoration: underline;"> <span style="color: #3366ff;"> <a style="color: #3366ff; text-decoration: underline;" href="https://app.diagrams.net/" target="_blank" rel="noopener noreferrer">diagrams.net </a> </span> </span>. Именно как инструмент <strong>взаимодействия разработчиков и проектирования</strong>, а не как картинка или часть документации (да и документации тоже). Удобно смотреть на систему в двух плоскостях. Одна - взгляд на архитектуру с точки зрения разработчика (классы и их взаимодействие) и, вторая, с точки зрения аналитика, devops (разбиение на микросервисы и их функциональность). Архитектурим прямо на доске, online. Аналитик (и не только он) видит вопросы и есть время "на подумать", уточнить. При следующем входе подсвечивается что изменилось.</p>
<p><span style="font-weight: 400;"> <img class="pull-center" src="images/miro3.png" alt="" /><br /> </span></p>
<h3>Выделение отдельного микросервиса</h3>
<p>Описать выделение отдельного микросервиса(причины, план ввода в работу, проблемы ввода)???. А точно надо тут? Масса лит-ры на эту тему.</p>
<h3>Марк, постреляем?</h3>
<p>Я о devops. Марк - это король devops-а, с которым мне повезло работать. "Постреляем" это про нагрузочные испытания <a style="text-decoration: underline; color: #3366ff;" title="yandex-tank" href="https://github.com/yandex/yandex-tank" target="_blank" rel="noopener noreferrer">yandex-tank</a>. Хотя я не только про них (испытания).</p>
<p>Иногда случается, что devops инженеры как-то за скобками команды. Вам повезло, если разработчики в контакте с devops инженером. С нормальным devops инженером есть о чем поговорить.</p>
<ul>
    <li>Он пришлет вам результаты тестирования и развертывания.</li>
    <li>Проведет нагрузочные испытания.</li>
    <li>Укажет чего вы там забыли чего-то задокументировать и понятно и логично отразит изменения в разных wiki системах (в которых часто каша).</li>
    <li>Вытащит условия возникновения ошибки на prode (хотя сами виноваты, когда отмахнулись в виде e.printStackTrace ()). От пользователей, в этом случае, чаще мало толку ("Я работала как обычно, нажала эту кнопочку и вдруг все пропало" или "Ничего не работает").</li>
    <li>Организует версионирование в понятной схеме.</li>
    <li>Покажет где и что не протестировано.</li>
    <li>Укажет на перерасход ресурсов. А то и поделится опытом, как оптимизировать (база, очереди, кеши).</li>
</ul>
<p>И много чего еще. В общем это источник порядка и подотрет вам сопельки.</p>
<h3>Новичок в команде</h3>
<p>Какой-то нечеловеческий снобизм и в то же время <b>безразличие(!)</b> к новому сотруднику. Вход в новый проект, в другую команду. Тут и подключение через vpn, и знакомство с ресурсами, и людьми, с самим проектом и т.п. Лениво так какую-то <b>левую</b> ссылочку кинут на jira(не на раздел проекта, а просто на корень jira), после 10-го обращения, если повезет то и на репозитории. Или тупо: посмотри в jira, к которой <b>нет доступа</b>, т.к. не дали vpn, и куда за ним бежать неизвестно. И за куратором приходится побегать.<br /> Или наоборот, новичку отправят МАССУ ссылок, документов, так что череп треснет. А большая часть этой информации мало относится к проекту или второстепенны.</p>
<p>Решение очень простое. В jira задача: "Довести нового сотрудника до 2-3 push в репу" (как-то неоднозначно звучит. В чью репу push? <img src="media/editors/tinymce/plugins/emoticons/img/smiley-laughing.gif" alt="laughing" />). Срок - неделя или две. Объем пушей по самому минимуму, задачи выбирает куратор или даже специально создает. 2-3 задачи никак ни на что не влияют. Тут цель - освоиться, отмазки типа "новичок тупой" в топку. Тема для <a style="color: #3366ff; text-decoration: underline;" title="Далее" href="index.php/35-novichok-v-komande" target="_blank" rel="noopener noreferrer">отдельной статьи</a>.</p>
<p>И еще раз - доступ к РЕСУРСАМ. Доставать того, кто рулит этим доступом по несколько раз в день. Именно, доставать. Испытательный срок не резиновый, а необходимого доступа для новичка за этот срок можно так и не получить. В результате - <u><b>увольнение</b> сотрудника, из-за чьего-то <b>бакланства</b></u>.</p>
<p>И еще раз - доступ к РЕСУРСАМ!!! Контролировать предоставление доступа. <b>Лично</b> контролировать предоставление этого доступа! Новичка могут подключить к совсем <b>ДРУГОМУ ПРОЕКТУ</b> (реальный случай, и опять бакланство).</p>
<h3>Команда</h3>
<p><img src="images/burlaki_small.png" align="left" hspace="15" vspace="5" /> <a style="text-decoration: underline; color: #3366ff;" title="Идеальная команда" href="index.php/notes/29-idealnaya-komanda" target="_blank" rel="noopener noreferrer">Идеальная команда</a>. Не жалеть времени на общение бек-эндера с бек-эндером. Глаз замыливается. Даже <b>отдельный</b> дейлик для бек-эндеров, даже если их всего двое. Апрувим друг-друга. Вопросы для дейлика размещать прямо в коде в виде "todo?". Todo помогает переварить речь перед обсуждением (и не только автора todo). Кстати, лучше вечером. Решается еще не мелкая проблема - оторвать коллегу от компа, от кода. Иначе, будет сидеть до ночи. Выгорание это все-таки не буржуйские сопли. <br />Каменты, желательно, писать в виде совета(может быть...), или размышления (а если так?...), или в виде "А может сделаем так же, как там(ссылка на commit)?", <b>и без оценок</b> типа "хня" и т.п. В запущенном случае перегибы в оценках могут привести к безинициативности, конформизму.</p>
<h3>Много проектов, много команд</h3>
<p><img src="images/shiva.jpg" align="right" hspace="15" vspace="5" />Бывает что программист работает на 2-3 проектах и в разных командах параллельно. Даже термин для этого придумали - multiscrum. Есть и плюсы, есть и минусы.<br /> Плюсы: "Расшаривание" знаний. Можно посоветоваться с коллегами с соседнего проекта, "подглядеть" решения.<br /> Минусы: Как делить время без ущерба проектам и себе? Понятно, что скорость развития проекта страдает. Нужно с коллегами как-то синхронизироваться. Появляется какая-то поверхностность и временнЫе издержки на "мозг переключить", посмотреть что изменилось.<br /> Спасает режим - в течении спринта, подряд 2-3 дня на один проект, 2-3 дня на другой. И эти дни должны быть четко определены (понедельник,вторник - один проект, среда, четверг - другой, пятница - резерв, на "хвосты подчистить"). По неделе на проект - много. И больше двух проектов как-то многовато. Ну или если один из проектов уже на проде и за ним нужно только приглядывать (hotfix, консультации).</p>
<h3>О! Женщины!</h3>
<p>Просто само присутствие в команде как-то дисциплинирует что-ли. Опять же внимательность к мелочам, порядку, терпеливость.</p>
<h3>О неуверенности</h3>
<p>Неуверенность это незнание (проекта, команды, сроков). Иногда, эту неувернность путают с непрофессиионализмом.
Обратная сторона - самоуверенность. Рекомендуется писать код исходя из той информации, которая у тебя есть. Нормальный ревьювер откоментит, если что не так.</p>

<h3>Ну и все, вроде.</h3>
<p>Разработчики не склонны к болтливости, что иногда здорово мешает.</p>
<p><span style="font-weight: 400;"> Для кого я это все написал? Да для себя прежде всего, чтобы не забывать при смене работы. Мозги причесать.</span></p>
<p><span style="font-weight: 400;">Длинно получилось.</span></p>
<hr />
<p><span style="font-weight: 400;"><strong style="font-weight: 400;"><b>PS</b></strong><br /> Еще бы не забыть:<br /><br /> Черкнуть пару слов в отдельной статье, подробно и с примерами, о причинах возникновения, сопровождения и ухода от <a style="text-decoration: underline; color: #3366ff;" title="такого чуда" href="index.php/36-karaf-v-mikroservise-kuber" target="_blank" rel="noopener noreferrer">karaf в микросервисе kubernetes</a>. Модульный karaf в микросервисе. Какая-то необъяснимая тяга к модульной java. Я и сам болел этим делом. Уже пара проектов за плечами перехода от karaf в "чистые" микросервисы kubernetes. Как же легче становится писать. <br /><br /> Отдельная тема <b>восстановление после перерыва</b>. Вариантов нет - писать код). Свои мелкие проекты от rest до базы.<br /> <br /> </span></p>