<p>Дополнительные к чему? К текстовому редактору)</p>
Проект и описание находится тут:
<a title="https://github.com/cherepakhin/shop_kotlin" href="https://github.com/cherepakhin/shop_kotlin"
   style="text-decoration: underline; color: #3366ff;"
   target="_blank" rel="noopener noreferrer">https://github.com/cherepakhin/shop_kotlin</a>
<hr id="system-readmore" />
<h2>Анализаторы кода</h2>
Используются для автоматической проверки кода на "чистоту".
<ul>
    <li><a href="#idea_analizer">Статический анализатор Idea Analyzer</a></li>
    <li><a href="#sonarcube_analizer">Статический анализатор SonarCube</a></li>
</ul>
<ul>
    <li><a href="#jpa">Замечание о JPA Entity классах с Kotlin</a></li>
</ul>
<ul>
    <li><a href="#profiles">Spring profiles</a></li>
</ul>
<h2>Тестирование</h2>
<ul>
    <li><a href="#unit">Unit тестирование</a></li>
    <li><a href="#test_coverage">Покрытие тестами</a></li>
    <li><a href="#integration_tests">Интеграционное тестирование</a></li>
        <ul>
            <li><a href="#httpie_tests">Ручные тесты с httpie</a></li>
            <li><a href="#auto_integration_tests">Автоматические интеграционные тесты</a></li>
            <li><a href="#data_jpa_tests">DataJpa tests</a></li>
            <li><a href="#restassured_tests">RestAssured tests</a></li>
        </ul>
    <li><a href="#load_tests">Нагрузочное тестирование</a></li>
</ul>
<h2>Документирование</h2>
<ul>
    <li><a href="#swagger">Swagger</a></li>
    <li><a href="#actuator">Spring Actuator</a></li>
</ul>
<h2>CI/CD</h2>
<ul>
    <li><a href="#prometheus">Prometheus</a></li>
    <li><a href="#cpu_usage">Пример просмотра использования CPU в Prometheus</a></li>
    <li><a href="#run_prometheus_in_docker">Запуск prometheus в docker</a></li>
    <li><a href="#grafana">Просмотр ресурсов с помощью Grafana</a></li>
    <li><a href="#jmc">Просмотр ресурсов с помощью Java Mission Control</a></li>
</ul>
<ul>
    <li><a href="#jenkins">Сборка Jenkins</a></li>
    <li><a href="#nexus">Nexus</a></li>
</ul>
<h2>Инструменты</h2>
<ul>
    <li><a href="#docker">Docker</a></li>
    <li><a href="#caching">Кеширование</a></li>
    <li><a href="#logging">Логирование</a></li>
</ul>
<h2>Использование ChatGPT</h2>
<ul>
    <li><a href="#easycode_idea">ChatGPT-EasyCode в Idea</a></li>
    <li><a href="#easycode_vscode">ChatGPT-EasyCode в VSCode</a></li>
</ul>
<hr/>
<ul>
    <li><a href="#todo">TODO</a></li>
    <li><a href="#other">Примечания</a></li>
    <li><a href="#links">Ссылки</a></li>
</ul>
<hr/>
<h3>Анализаторы кода</h3>
<a id="idea_analizer"></a>
<h3 dir="auto">Статический анализатор Idea Analyzer</h3>
Idea Analyzer вызывается из основного меню "Code" -> "Inspect code...". Или из контекстного меню в панели <b>Project</b>, выбрать класс и выбрать меню <b>Analyze -> Inspect Code</b>
<a id="sonarcube_analizer"></a>
<h3 dir="auto">Статический анализатор SonarCube</h3>
Взято отсюда <a title="https://russianblogs.com/article/7201801081/" href="https://russianblogs.com/article/7201801081/">https://russianblogs.com/article/7201801081/</a><br/>
Коротко: в области Project правый клик на src/main/kotlin выбрать <b>"Analize with SonarLint"</b>. Отчет будет в "Report".
<a id="jpa"></a>
<h3 dir="auto">Замечание о JPA Entity классах с Kotlin</h3>
Источник: <a title="https://habr.com/ru/companies/haulmont/articles/572574/" href="https://habr.com/ru/companies/haulmont/articles/572574/">https://habr.com/ru/companies/haulmont/articles/572574/</a><br/>
Примеры из источника: <a title="https://github.com/Klimenkoob/spring-kotlin-hibernate" href="https://github.com/Klimenkoob/spring-kotlin-hibernate">https://github.com/Klimenkoob/spring-kotlin-hibernate</a><br/>
Рекомендации:<br/>
<ul>
    <li>Warning in Idea: Data class not recommended for JPA Entity. Вопрос: почему не использовать Data-классы? Ответ: Потому что они финальны сами по себе, имеют по всем полям определенные equals, hashCode и toString. А это недопустимо в связке с Hibernate.</li>
    <li>Явно помечать ключевым словом open все Entity. Согласно спецификации JPA, все классы и свойства, связанные с JPA, не должны быть final. В отличие от Java, в Kotlin классы, свойства и методы по умолчанию final. Поэтому их нужно явно помечать ключевым словом open.</li>
    <li>Явно определять hashCode(), equals(), toString(). При определении внимание на lazy поля (как и в Java).</li>
    <li>Добавить nullable = false. <pre class="language-java">
<code>@ManyToOne(fetch = FetchType.LAZY, optional = false)
@JoinColumn(name = "client_id", nullable = false)
lateinit var client: Client
</code></pre></li>
</ul>

<a id="profiles"></a>
<h3 dir="auto">Spring profiles</h3>
Общие параметры для обоих профилей в <a title="https://github.com/cherepakhin/shop_kotlin/blob/dev/src/main/resources/application.yaml" href="https://github.com/cherepakhin/shop_kotlin/blob/dev/src/main/resources/application.yml" target="_blank">application.yml</a>. В этом же файле указан профиль по умолчанию (active: dev):
<pre class="language-java">
<code>spring:
  profiles:
    active: dev
  application:
    name: shop_kotlin
</code></pre>
Профили для dev: <a title="https://github.com/cherepakhin/shop_kotlin/blob/dev/src/main/resources/application-dev.yaml" href="https://github.com/cherepakhin/shop_kotlin/blob/dev/src/main/resources/application-dev.yml" target="_blank">application-dev.yml</a>
и prod: <a title="https://github.com/cherepakhin/shop_kotlin/blob/dev/src/main/resources/application-prod.yaml" href="https://github.com/cherepakhin/shop_kotlin/blob/dev/src/main/resources/application-prod.yml" target="_blank">application-prod.yml</a><br/>
Запуск с указанием профиля: <pre class="language-java">
<code>java -D"spring.profiles.active=dev" -jar app.jar</code></pre>
Запуск с gradle: <pre class="language-java">
<code>./gradlew bootRun -Dspring.profiles.active='dev'</code></pre>
или установить env переменную: <pre class="language-java">
<code>SPRING_PROFILES_ACTIVE=dev ./gradlew clean bootRun
</code></pre>

<a id="unit"></a>
<h3 dir="auto">Unit тестирование</h3>
<pre class="language-java">
<code>./gradlew test</code></pre>
Примеры отбора тестов:<pre class="language-java"><code>./gradlew test --tests '*EntityTest'
./gradlew test --tests '*Rest*'
./gradlew test --tests ProductDTOTest
./gradlew test --tests '*TestIntegration'
./gradlew test --tests '*MockMvcTest'
</code></pre>

<a id="test_coverage"></a>
<h3 dir="auto">Покрытие тестами</h3>
Использован <a title="https://www.eclemma.org/jacoco/" href="https://www.eclemma.org/jacoco/">jacoco</a>.
Отчет формируется при прогоне тестов:<pre class="language-java"><code>./gradlew test jacocoTestReport</code></pre>
Отчет будет в папке build/reports/jacoco/test/html:
<p><img style="display: block; margin-left: auto; margin-right: auto;" title="Jacoco report" src="images/shop_kotlin/jacoco_report.png"
        alt="Example" width="1096" height="220"/></p>
Пример отчета по конкретному классу:
В отчете НЕТ информации о результатах тестирования, только протестирован участок кода или нет. Пример:
<p><img style="display: block; margin-left: auto; margin-right: auto;" title="Jacoco report" src="images/shop_kotlin/jacoco_example.png"
        alt="Example" width="766" height="420"/></p>
Красным или желтым выделены непротестированные участки кода, зеленым протестировано.
<a id="integration_tests"></a>
<h3 dir="auto">Интеграционное тестирование</h3>
Вообще, интеграционные тесты должны быть в отдельном проекте (см. https://github.com/cherepakhin/shop_kotlin_restassured_test).
В примере оставил только тесты работы с базой данных. Имена интеграционных тестов должны заканчиваться ..TestIntegration.
Пример: Прогнать все, кроме интеграционных (включены только *Test, исключены *TestIntegration)
<pre class="language-java">
<code>./gradlew clean test --tests *Test
</code></pre>
Только интеграционные:
<pre class="language-java">
<code>./gradlew clean test --tests *TestIntegration*
./gradlew clean test --tests *TestIntegration
</code></pre>
В проекте <b>shop_kotlin</b> включено специальное протоколирование прохождения тестов в файле <a title="https://github.com/cherepakhin/shop_kotlin/blob/dev/build.gradle.kts" href="https://github.com/cherepakhin/shop_kotlin/blob/dev/build.gradle.kts" target="_blank">build.gradle.kts</a><br/>:
<pre class="language-java">
<code>...
tasks.withType<Test> {
    ...
    // Show test log
    testLogging {
        events("passed", "skipped", "failed")
    }
    ...
}
</code></pre>
Отчет о прохождении тестов:<br/>
<pre class="language-java">
<code>...
GroupProductServiceImplMockTest > existsByN() PASSED
GroupProductServiceImplMockTest > create() PASSED
GroupProductServiceImplMockTest > getByN() PASSED
GroupProductServiceImplMockTest > update() PASSED
GroupProductServiceImplMockTest > getSubGroups() PASSED
...
BUILD SUCCESSFUL in 3m
</code></pre>

<a id="httpie_tests"></a>
<h3 dir="auto">Примеры тестов httpie</h3>
Echo запрос для простой проверки работоспособности (:8980/shop_kotlin/ - базовый путь проекта):
<pre class="language-text">
<code>http :8980/shop_kotlin/api/echo/TEST_MESSAGE

HTTP/1.1 200
Connection: keep-alive
Content-Length: 3
Content-Type: text/plain;charset=UTF-8
Date: Thu, 15 Jun 2023 07:30:38 GMT
Keep-Alive: timeout=60

TEST_MESSAGE
</code></pre>
Поиск по имени Product:
<pre class="language-text">
<code>http :8980/shop_kotlin/api/group_product/find?name='Comp'

[
    {
        "haveChilds": true,
        "id": 2,
        "name": "Computers",
        "parentId": 1
    },
    {
        "haveChilds": false,
        "id": 3,
        "name": "Desktop Computers",
        "parentId": 2
    }
]
</code></pre>
POST запрос на изменение Product:
<pre class="language-text">
<code>http POST :8980/shop_kotlin/api/product/ < ./src/test/json_test/product.json
</code></pre>
<a title="https://github.com/cherepakhin/shop_kotlin/blob/dev/src/test/json_test/product.json" href="https://github.com/cherepakhin/shop_kotlin/blob/dev/src/test/json_test/product.json" target="_blank">https://github.com/cherepakhin/shop_kotlin/blob/dev/src/test/json_test/product.json</a><br/>

<a id="auto_integration_tests"></a>
<h3 dir="auto">Автоматические интеграционные тесты</h3>
Два варианта тестирование - c Spring @DataJpaTest и через RestAssured (это bdd тестирование). Совершенно разные тесты, для совершенно разных целей. DataJpaTest на уровне БД, RestAssured - сквозное тестирование от rest до БД.
<a id="data_jpa_tests"></a>
<h3 dir="auto">DataJpa tests</h3>
Тестируется работа с базой данных с использованием @DataJpaTest.
Находятся в пакете <a title="https://github.com/cherepakhin/shop_kotlin/tree/dev/src/test/kotlin/ru/perm/v/shopkotlin/datajpatest"
   href="https://github.com/cherepakhin/shop_kotlin/tree/dev/src/test/kotlin/ru/perm/v/shopkotlin/datajpatest"
   target="_blank">ru.perm.v.shopkotlin.datajpatest</a><br/>
Пример:
<pre class="language-java">
<code>...
@DataJpaTest
class PriceRepositoryDataJpaTestIntegration {
    @Autowired
    lateinit var priceRepository: PriceRepository

    @Test
    fun getAll() {
        val prices = priceRepository.findAll()

        assertEquals(18, prices.size);
    }
    ...
}
</code></pre>

<a id="restassured_tests"></a>
<h3 dir="auto">RestAssured tests</h3>
Находятся в отдельном репозитории <a title="https://github.com/cherepakhin/shop_kotlin_restassured_test"
                                     href="https://github.com/cherepakhin/shop_kotlin_restassured_test"
                                     target="_blank">https://github.com/cherepakhin/shop_kotlin_restassured_test</a><br/>
Там же более подробное описание методики и особенностей.
Пример: <pre class="language-java">
<code>....
@DisplayName("Products tests /product")
class ProductRestTest {
    val mapper = ObjectMapper()

    @Test
    @DisplayName("GET count_names of products is status=200")
    fun getNumberOfProductNames_HttpStatusIsOK() {
        RestAssured.given().`when`().get(PRODUCT_PATH + "count_names").then()
            .statusCode(HttpStatus.SC_OK)
    }
....
}
....
@DisplayName("Group products tests")
class GroupProductRestTest {
....
    @Test
    @Epic("REST API getAll()")
    @DisplayName("TEST GET Request GroupProductRest.all() check dtos")
    fun getAll_check_DTO() {
        val json: String = given().get(CONSTS.GROUP_PATH).asString()
        val groups: List<GroupProductDTO> = mapper.readValue(json, object : TypeReference<List<GroupProductDTO>>() {})
        assertEquals(7, groups.size)

        val g0 = groups.get(0)
        assertEquals(1, g0.n)
        assertEquals(GroupProductDTO(1, "IT products", true, -1), groups.get(0))
        assertEquals(GroupProductDTO(2, "Computers", true, 1), groups.get(1))
        assertEquals(GroupProductDTO(3, "Desktop Computers", false, 2), groups.get(2))
    }
....
}
</code></pre>
Проведение теста:
<pre class="language-java"><code>$ mvn clean test
</code></pre>

Отчет о результатах тестирования выведен в виде Allure Report (<a title="https://allurereport.org/"
                                                                  href="https://allurereport.org/"
                                                                  target="_blank">https://allurereport.org/</a>).
Для просмотра отчета в браузере выполнить:
<pre class="language-java"><code>$ ./allure serve target/surefire-reports/
</code></pre>

Результат тестирования:
<p><img style="display: block; margin-left: auto; margin-right: auto;" title="Allure report" src="images/shop_kotlin/allure_result_test.png"
        alt="Example" width="841" height="565"/></p>
Результат тестирования с ошибками:
<p><img style="display: block; margin-left: auto; margin-right: auto;" title="Allure error report" src="images/shop_kotlin/allure_result_test_error.png"
        alt="Example" width="1328" height="566"/></p>
<a id="load_tests"></a>
<h3 dir="auto">Нагрузочное тестирование с помощью <a title="https://yandextank.readthedocs.io/en/latest/"
                                                     href="https://yandextank.readthedocs.io/en/latest/"
                                                     target="_blank">yandex-tank</a></h3>

Тесты предназначены для оценки использования ресурсов (CPU, RAM, NETWORK и т.п.) и находятся в отдельном репозитории <a title="https://github.com/cherepakhin/shop_kotlin_yandex_tank_test"
                                     href="https://github.com/cherepakhin/shop_kotlin_yandex_tank_test"
                                     target="_blank">https://github.com/cherepakhin/shop_kotlin_yandex_tank_test</a><br/>
Нагрузочное тестирование часто не проводят и метрики получают уже на prod c помощью средств мониторинга (н.п. Grafana).
Вопросы типа "Что будет при возросшей нагрузке?" остаются в стороне. И с другой стороны нагрузочное тестирование может показать узкие места при различных сценариях.
Кратко один из сценариев теста с помощью Yandex-tank. Сам yandex-tank крутится в Docker.
Скрипт для проведения теста <a title="https://github.com/cherepakhin/shop_kotlin_yandex_tank_test/blob/master/tank_run_shop_kotlin.sh"
                               href="https://github.com/cherepakhin/shop_kotlin_yandex_tank_test/blob/master/tank_run_shop_kotlin.sh"
                               target="_blank">./tank_run_shop_kotlin.sh</a>:
<pre class="language-java"><code>docker run --entrypoint yandex-tank \
-v $(pwd):/var/loadtest \
-v $SSH_AUTH_SOCK:/ssh-agent -e SSH_AUTH_SOCK=/ssh-agent \
--net host \
-it direvius/yandex-tank
</code></pre>
Описание теста описано в двух файлах load.yaml и ammo-uri.txt.<br/>
<br/>
<a title="https://github.com/cherepakhin/shop_kotlin_yandex_tank_test/blob/master/load.yaml"
   href="https://github.com/cherepakhin/shop_kotlin_yandex_tank_test/blob/master/load.yaml"
   target="_blank">load.yaml</a> описывает куда и чем "стрелять":
<pre class="language-java">
<code>
overload:
    enabled: true
    package: yandextank.plugins.DataUploader
    token_file: "token.txt"
phantom:
    address: 192.168.1.20:8980           # адрес тестируемого сервиса
    load_profile:                        # описание нагрузки
        load_type: rps                   # тип нагрузки: "rps" - количество запросов в секунду
        schedule: const(600, 180s)       # нагрузка постоянная (const) 600 rps в течении 3 минут
    ammofile: /var/loadtest/ammo-uri.txt # В ammo-uri.txt описано по какому REST стреляем
    ammo_type: uri
console:
    enabled: true
telegraf:
    config: monitoring.xml
    enabled: true
    kill_old: false
    package: yandextank.plugins.Telegraf
    ssh_timeout: 5s
</code></pre>
(комментарии # в целевом файле нужно убрать.)<br/>
<br/>
Содержимое <a title="https://github.com/cherepakhin/shop_kotlin_yandex_tank_test/blob/master/ammo-uri.txt"
   href="https://github.com/cherepakhin/shop_kotlin_yandex_tank_test/blob/master/ammo-uri.txt"
   target="_blank">ammo-uri.txt</a> (тестируемый запрос к API):
<pre class="language-java"><code>/shop_kotlin/api/group_product/find?name=Notebooks
</code></pre>
Это только очень примитивный "hello world" пример. Возможности yandex-tank <b>ОЧЕНЬ</b> широкие.
Необходимо сказать, что это не только инструмент, но и СЕРВИС. Результаты тестирования можно отправлять в этот сервис. Каких там только отчетов нет о проведенных тестов!
<p><img style="display: block; margin-left: auto; margin-right: auto;" title="Yandex tank report" src="images/shop_kotlin/ya_tank_result.png"
        alt="Example" width="647" height="396"/></p>
"При нагрузке 200rps, время ответ 98% запросов меньше 19.264 мсек."<br/><br/>
Несколько примеров можно найти тут <a title="https://github.com/cherepakhin/shop_kotlin_yandex_tank_test"
                                 href="https://github.com/cherepakhin/shop_kotlin_yandex_tank_test"
                                 target="_blank">https://github.com/cherepakhin/shop_kotlin_yandex_tank_test</a>.

<a id="swagger"></a>
<h3 dir="auto">Swagger</h3>
<a id="actuator"></a>
<h3 dir="auto">Spring Actuator</h3>
<a id="prometheus"></a>
<h3 dir="auto">Prometheus</h3>
<a id="cpu_usage"></a>
<h3 dir="auto">Пример просмотра использования CPU в Prometheus</h3>
<a id="run_prometheus_in_docker"></a>
<h3 dir="auto">Запуск prometheus в docker</h3>
<a id="grafana"></a>
<h3 dir="auto">Просмотр ресурсов с помощью Grafana</h3>
<a id="jmc"></a>
<h3 dir="auto">Просмотр ресурсов с помощью Java Mission Control</h3>
<a id="jenkins"></a>
<h3 dir="auto">Сборка Jenkins</h3>
<a id="nexus"></a>
<h3 dir="auto">Nexus</h3>
<a id="docker"></a>
<h3 dir="auto">Docker</h3>
<a id="caching"></a>
<h3 dir="auto">Кеширование</h3>
<a id="logging"></a>
<h3 dir="auto">Логирование</h3>
<a id="easycode_idea"></a>
<h3 dir="auto">ChatGPT-EasyCode в Idea</h3>
<a id="easycode_vscode"></a>
<h3 dir="auto">ChatGPT-EasyCode в VSCode</h3>
<a id="todo"></a>
<h3 dir="auto">TODO</h3>
<a id="other"></a>
<h3 dir="auto">Примечания</h3>
<a id="links"></a>
<h3 dir="auto">Ссылки</h3>