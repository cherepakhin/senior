https://javarush.com/quests/lectures/questhibernate.level08.lecture00
https://worksolutions.ru/blog/kak-tranzakczii-pomogayut-obespechit-czelostnost-baz-dannyh/
https://habr.com/ru/articles/860982/

Есть две транзакции. Они производят обновление одной и той же строки. Вторая транзакция изменила строку и
зафиксировала свои изменения.
После этого зафиксировала свои изменения первая транзакция и перезаписала изменения второй транзакции.

<b>Грязное чтение (dirty read).</b> Первая транзакция изменила данные, но еще не зафиксировала свои изменения.
В это время вторая транзакция читает измененные данные. Если первая транзакция сделает отмену своих изменений - ROLLBACK,
то получится что вторая транзакция работает с данными, которых нет в базе данных.

<b>Уровни изоляции транзакций</b>

<b>Read uncommitted.</b> Это самый низкий уровень изоляции. Согласно стандарту SQL на этом уровне разрешено чтение грязных данных (незакоммиченных записей). Но в PostgreSQL на этом уровне чтение грязных данных не допускается.

<b>Read Committed.</b> По стандарту SQL на этом уровне не допускается чтение грязных данных. Таким образом в PostgreSQL уровни read uncommitted и read committed совпадают. Этот уровень по умолчанию установлен в PostgreSQL.

<b>Repeatable read.</b> Не допускается грязное чтение и неповторяющееся чтение. В PostgreSQL не допускается так же фантомное чтение. Транзакция, использующая этот уровень изоляции делает снимок БД при первом запросе после начала транзакции и работает с этим снимком до конца транзакции. Поэтому не возникает неповторяемости чтения. При этом если другая транзакция изменила данные входящие в состав снимка, то текущая транзакция эти же данные изменить не сможет. Запрос на изменение будет отклонен и потребуется делать изменения уже в новой транзакции (т.е. снова прочитать).

<b>Serializable.</b> Не допускается ни один из феноменов. На этом уровне снимок БД делается сразу после начала транзакции.

--------------------------------------------
https://javarush.com/quests/lectures/ru.javarush.java.spring.lecture.level06.lecture02

Spring может управлять транзакциями на множестве платформ и технологий, включая:

_JDBC_ — для работы напрямую с базами данных.
_JPA/Hibernate_ — для ORM-решений.
_JTA_ — для работы в распределённых системах (например, микросервисах).

Ну что, хотите больше примеров? Тогда давайте создадим менеджера транзакций в реальном приложении.

Пример настройки TransactionManager
@Configuration
@EnableTransactionManagement // Включаем управление транзакциями
public class AppConfig {

    @Bean
    public PlatformTransactionManager transactionManager(EntityManagerFactory emf) {
        return new JpaTransactionManager(emf); // Менеджер для _JPA/Hibernate_ — для ORM-решений.
    }
}

Использован jPa (JPA/Hibernate — для ORM-решений.), не jTa (JTA — для работы в распределённых системах)
--------------------------------------------