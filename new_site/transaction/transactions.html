<b>Read uncommitted.</b> Это самый низкий уровень изоляции. Согласно стандарту SQL на этом уровне разрешено чтение грязных данных (незакоммиченных записей). Но в PostgreSQL на этом уровне чтение грязных данных не допускается.
<br/>
<hr id="system-readmore" />
<b>Read Committed.</b> По стандарту SQL на этом уровне не допускается чтение грязных данных. Таким образом в PostgreSQL уровни read uncommitted и read committed совпадают. Этот уровень по умолчанию установлен в PostgreSQL.
<br/>
<b>Repeatable read.</b> Не допускается грязное чтение и неповторяющееся чтение. В PostgreSQL не допускается так же фантомное чтение. Транзакция, использующая этот уровень изоляции делает снимок БД при первом запросе после начала транзакции и работает с этим снимком до конца транзакции. Поэтому не возникает неповторяемости чтения. При этом если другая транзакция изменила данные входящие в состав снимка, то текущая транзакция эти же данные изменить не сможет. Запрос на изменение будет отклонен и потребуется делать изменения уже в новой транзакции (т.е. снова прочитать).
<br/>
<b>Serializable.</b> Не допускается ни один из феноменов. На этом уровне снимок БД делается сразу после начала транзакции.
<br/>
<b>Грязное чтение (dirty read).</b> Первая транзакция изменила данные, но еще не зафиксировала свои изменения.
В это время вторая транзакция читает измененные данные. Если первая транзакция сделает отмену своих изменений - ROLLBACK,
то получится что вторая транзакция работает с данными, которых нет в базе данных.<br/>

<a style="text-decoration: underline; color: #3366ff;" href="https://javarush.com/quests/lectures/ru.javarush.java.spring.lecture.level06.lecture02" target="_blank" rel="noopener noreferrer">Введение в управление транзакциями в Spring (javarush)</a>
Конспект:<br/>
<ul>
    <li>Spring может управлять транзакциями на множестве платформ и технологий, включая:<br/>
        <b>JDBC</b> — для работы напрямую с базами данных.<br/>
        <b>JPA/Hibernate</b> — для ORM-решений.<br/>
        <b>JTA</b> — для работы в распределённых системах (например, микросервисах).<br/>
    </li>
</ul>

Пример настройки TransactionManager:
<div style="background: #ffffff; overflow: auto; width: auto; border: solid #092A8F; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">
@Configuration
@EnableTransactionManagement // Включаем управление транзакциями
public class AppConfig {

    @Bean
    public PlatformTransactionManager transactionManager(EntityManagerFactory emf) {
        return new JpaTransactionManager(emf); // Менеджер для _JPA/Hibernate_ — для ORM-решений.
    }
}
</pre></div>
Использован jPa (JPA/Hibernate — для ORM-решений.), не jTa (JTA — для работы в распределённых системах).<br/>
<b>Ссылки:</b>
<ul>
    <li><a style="text-decoration: underline; color: #3366ff;" href="https://javarush.com/quests/lectures/questhibernate.level08.lecture00" target="_blank" rel="noopener noreferrer">Транзакции при работе с базой данных (javarush)</a></li>
    <li><a style="text-decoration: underline; color: #3366ff;" href="https://worksolutions.ru/blog/kak-tranzakczii-pomogayut-obespechit-czelostnost-baz-dannyh/" target="_blank" rel="noopener noreferrer">Как транзакции помогают обеспечить целостность баз данных</a></li>
    <li><a style="text-decoration: underline; color: #3366ff;" href="https://habr.com/ru/articles/860982/" target="_blank" rel="noopener noreferrer">Транзакции в базах данных на примере PostgreSQL (habr)</a></li>
</ul>