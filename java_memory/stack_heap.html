<p><b>Stack</b> – Каждый поток имеет свой стек, который создается в тоже время, когда и создается поток.
Стек содержит фреймы, которые создаются при каждом вызове метода и хранят локальные переменные и
промежуточные результаты, возвращают значения для методов и выбрасывают исключения, если это необходимо.
Фрейм разрушается, когда вызов метода завершается, неважно является это завершение успешным или с исключением.
Ниже приведен пример кода:
<pre class="language-java"><code>public class Memory {
        public static void main(String[] args) {
            main(args);
        }
    }</code></pre>
Его результатом будет исключение <b>StackOverflowError</b>, потому что этот код бесконечно
вызывает сам себя, соответственно память в стеке заканчивается. Существуют возможности
увеличить размер стека, для этого необходимо при запуске добавить аргумент для виртуальной
машины <b>–Xss1024k</b>. Это установит размер стека равным 1 мегабайту.
</p>
<p><b>Heap</b> – создается в момент запуска виртуальной машины, это область памяти в
которой хранятся все созданные в процессе работы программы <b>ССЫЛОЧНЫЕ</b> типы данных. Он
существует только один и разделяется между всеми потоками, существующими в программе.
Для очистки от более неиспользуемых объектов (те объекты, на которые никто больше не
ссылается) используется <b>сборщик мусора (garbage collector)</b>. Аргумент для виртуальной
машины <b>-Xmx1024k</b>. Ошибка <b>OutOfMemory</b>.
</p>
<p><b>Volatile</b> – говорит потоку что переменная может меняться другими потоками, и информирует
поток о необходимости обращаться к последней версии, а не к хешированной копии и своевременно
распространять изменения.
Например, когда мы в многопоточном приложении используем паттерн Синглтон в котором <b>применяем синхронизацию</b>
и хотим чтобы синхронизация осуществлялась только один раз при инициализации объекта,
а не каждый раз, когда мы вызываем getInstance(), тогда модификатор volatile используем для объектной ссылки :
<pre class="language-java"><code>public class Singleton {
    private static volatile Singleton instance;   // !
    private Singleton(){
    }
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {       // !
                if (instance == null)             // !
                    instance = new Singleton();   // !
            }                                     // !
        }
        return instance;
    }
}
</code></pre>
Внимание на <b>static</b>, <b>volatile</b>, <b>synchronized</b>.
</p>