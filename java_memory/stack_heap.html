<p><b>Stack</b> – Каждый поток имеет свой стек, который создается в тоже время, <b>когда создается поток</b>.
Стек (лакальная или рабочая память потока) содержит фреймы, которые создаются при каждом вызове метода и хранят локальные переменные и
промежуточные результаты, возвращают значения для методов и выбрасывают исключения, если это необходимо.
Фрейм разрушается, когда вызов метода завершается, неважно является это завершение успешным или с исключением.
Ниже приведен пример кода:
<pre class="language-java"><code>public class Memory {
        public static void main(String[] args) {
            main(args);
        }
    }</code></pre>
Его результатом будет исключение <b>StackOverflowError</b>, потому что этот код бесконечно
вызывает сам себя, соответственно память в стеке заканчивается. Существуют возможности
увеличить размер стека, для этого необходимо при запуске добавить аргумент для виртуальной
машины <b>–Xss1024k</b>. Это установит размер стека равным 1 мегабайту.
</p>
<p><b>Heap</b> – создается в момент запуска виртуальной машины, это область памяти в
которой хранятся все созданные в процессе работы программы <b>ССЫЛОЧНЫЕ</b> типы данных. Он
существует только один и разделяется между всеми потоками, существующими в программе.
Для очистки от более неиспользуемых объектов (те объекты, на которые никто больше не
ссылается) используется <b>сборщик мусора (garbage collector)</b>. Аргумент для виртуальной
машины <b>-Xmx1024k</b>. Ошибка <b>OutOfMemory</b>.
</p>
<p><b>Volatile</b> – говорит потоку что переменная может меняться другими потоками, и информирует
поток о необходимости обращаться к последней версии (<b>heap</b>), а не к хешированной копии (<b>stack</b>) и своевременно
распространять изменения.
Например, когда мы в многопоточном приложении используем паттерн Синглтон в котором <b>применяем синхронизацию <u>synchronized...</u> (stack -&gt; heap)</b>
и хотим чтобы синхронизация осуществлялась <b>только один раз при инициализации объекта</b>,
а не каждый раз, когда мы вызываем getInstance(), тогда модификатор volatile используем для объектной ссылки :
<pre class="language-java"><code>public class Singleton {
    private static volatile Singleton instance;   // ! может меняться другими потоками
    private Singleton(){
    }
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {       // ! При выходе из synchronized
                if (instance == null)             // ! синхронизироать stack -> heap
                    instance = new Singleton();   // !
            }                                     // !
        }
        return instance;
    }
}
</code></pre>
(Внимание на <b>static</b>, <b>volatile</b>, <b>synchronized</b>)<br/>
Еще одно объяснение: <a title="Еще одно объяснение"
   style="text-decoration: underline; color: #3366ff;"
   target="_blank"
   href="https://timmson.github.io/java-interview/009-concurrency.html"
   rel="noopener noreferrer">https://timmson.github.io/java-interview/009-concurrency.html</a>.
С точки зрения Java все переменные (за исключением локальных переменных, объявленных внутри метода) хранятся в <u>главной</u> памяти, которая доступна всем потокам. Кроме этого, каждый поток имеет <u>локальную</u>(рабочую) память, где он хранит копии переменных, с которыми он работает, и при выполнении программы поток работает только с этими копиями.<br/><br/>
<b>При входе</b> в <u>synchronized</u> метод или блок поток обновляет содержимое <u>локальной</u> памяти, а <b>при выходе</b> из synchronized метода или блока поток записывает изменения, сделанные в <u>локальной</u> памяти, в <u>главную</u>.
